<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--
    Thanks to
    https://github.com/destruc7i0n/minecraft-textures
    https://github.com/South-Paw/typeface-minecraft
    -->

    <title>Storage room</title>
    <meta name="description" content="Autosorter too BIG, must FIND"/>

    <link rel="stylesheet" type="text/css" href="/sheep3.css">
    <script src="/sheep3.js" charset="utf-8"></script>

    <style>
      @import url('https://unpkg.com/@south-paw/typeface-minecraft@1.0.0/index.css');
      :root {
        --cell-size: 20px;
      }
      body {
        font-family: 'Minecraft';
        font-size: 12px;
        background-color: #222;
      }
      .board {
        position: absolute;
        top: 0;
        left: 0;
        transform: translate(calc(var(--x) * var(--cell-size)), calc(var(--y) * var(--cell-size)));
        width: calc(var(--width) * var(--cell-size));
        height: calc(var(--height) * var(--cell-size));
        font-size: 0;
        background-size: calc(2 * var(--cell-size));
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200' viewBox='0 0 2 2'%3E%3Cpath fill='%23333' d='M0 0h1v2h1V1H0z'/%3E%3C/svg%3E");
      }
      .cell {
        position: absolute;
        top: 0;
        left: 0;
        width: var(--cell-size);
        height: var(--cell-size);
        image-rendering: crisp-edges;
        image-rendering: pixelated;
        background-size: contain;
        transform: translate(calc(var(--x) * var(--cell-size)), calc(var(--y) * var(--cell-size)));
      }
      .highlighted {
        background-color: rgba(57, 155, 57, 0.5);
        box-shadow: 0 0 10px white;
      }
      .mouseover {
        position: fixed;
        z-index: 5;
        background-color: rgba(15, 0, 15, 0.8);
        border: 1px solid #270658;
        padding: 10px;
        pointer-events: none;
        white-space: pre-wrap;
        max-width: 500px;
      }
      .chest-name,
      .chest-items {
        display: inline-block;
      }
      .chest-name:not(:first-child) {
        margin-top: 10px;
      }
      .chest-items {
        color: rgba(255, 255, 255, 0.5);
      }
      .search-area {
        position: fixed;
        top: 0;
        right: 0;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 1;
        width: 300px;
      }
      .search-box {
        padding: 10px;
        width: 100%;
      }
      .results {
        list-style: none;
        margin: 0;
        padding: 0;
        height: 50vh;
        overflow: auto;
        position: relative;
      }
      .result {
        position: absolute;
        padding: 10px;
        padding-left: 40px;
        background-size: 30px;
        background-position: 5px 50%;
        background-repeat: no-repeat;
        image-rendering: crisp-edges;
        image-rendering: pixelated;
        white-space: pre;
        width: 100%;
        box-sizing: border-box;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
      }
      .result:not(.selected):hover {
        background-color: rgba(255, 255, 255, 0.1);
      }
      .selected {
        background-color: #6b87b1;
      }
    </style>
  </head>
  <body>
    <div class="search-area">
      <input
        type="search"
        class="search-box"
        id="search"
        placeholder="Search for items"
        autofocus>
      <ul class="results" id="results"></ul>
    </div>
    <script type="module">
      import { prepare, findItemBy } from './parse-storage-room.txt.js'
      import { Board, ElemBoard } from './storage-room-a-star.js'
      import { Directory } from './storage-room-search-results.js'

      async function main () {
        const { textures, stackables, data } = await prepare()
        const zStart = stackables.floor1Left[0][0]

        const chests = []
        const chestTexture = findItemBy(textures, 'minecraft:chest').texture
        function addStackablesTo (board, stackables, x) {
          for (const [z, item] of stackables) {
            const entry = findItemBy(textures, item)
            board.setSafely(x, z - zStart, {
              texture: entry.texture,
              entries: [
                {
                  name: entry.readable,
                  items: [item]
                }
              ]
            })
            chests.push({ items: [item], board, x, y: z - zStart })
          }
        }
        function addUnstackablesTo (board, unstackables, x) {
          for (let y = 0; y < unstackables.length; y++) {
            const chestStack = unstackables[y]
            if (chestStack.length) {
              board.setSafely(x, y, {
                texture: chestTexture,
                entries: chestStack
              })
              chests.push({
                items: [].concat(...chestStack.map(chest => chest.items)),
                board,
                x,
                y
              })
            }
          }
        }

        const ladderTexture = findItemBy(textures, 'minecraft:ladder').texture
        function addLadderPair (board1, x1, y1, board2, x2, y2) {
          board1.setSafely(x1, y1, {
            texture: ladderTexture,
            ladder: { board: board2, x: x2, y: y2 }
          })
          board2.setSafely(x2, y2, {
            texture: ladderTexture,
            ladder: { board: board1, x: x1, y: y1 }
          })
        }

        const rows = stackables.floor1Left[stackables.floor1Left.length - 1][0]
          - zStart + 1
        // Magic numbers yes please!
        const boards = {
          stackables: new Board(17, rows),
          elevatedLeft: new Board(5, rows),
          elevatedRight: new Board(5, rows),
          unstackables: new Board(9, data.unstackablesLeft.length + 1)
        }
        addStackablesTo(boards.stackables, stackables.floor1Left, 0)
        addStackablesTo(
          boards.stackables,
          stackables.floor1Right,
          boards.stackables.width - 1
        )
        addStackablesTo(boards.elevatedLeft, stackables.floor2Left, 0)
        addStackablesTo(
          boards.elevatedRight,
          stackables.floor2Right,
          boards.elevatedRight.width - 1
        )
        addUnstackablesTo(boards.unstackables, data.unstackablesLeft, 0)
        addUnstackablesTo(
          boards.unstackables,
          data.unstackablesRight,
          boards.unstackables.width - 1
        )
        addLadderPair(
          boards.stackables,
          Math.floor(boards.stackables.width / 2),
          data.stackableEntrance - zStart,
          boards.unstackables,
          Math.floor(boards.unstackables.width / 2),
          data.unstackablesLeft.length - 1
        )
        for (let y = 5; y < rows; y += 6) {
          addLadderPair(
            boards.stackables,
            5,
            y,
            boards.elevatedLeft,
            boards.elevatedLeft.width - 1,
            y
          )
          addLadderPair(
            boards.stackables,
            11,
            y,
            boards.elevatedRight,
            0,
            y
          )
        }

        const elemBoards = new Map([
          [
            boards.elevatedLeft,
            new ElemBoard(boards.elevatedLeft)
              .addTo(document.body)
              .setTag('elevatedLeft')
          ],
          [
            boards.stackables,
            new ElemBoard(boards.stackables)
              .moveTo(boards.elevatedLeft.width + 1, 0)
              .addTo(document.body)
              .setTag('stackables')
          ],
          [
            boards.elevatedRight,
            new ElemBoard(boards.elevatedRight)
              .moveTo(
                boards.elevatedLeft.width + boards.stackables.width + 2,
                0
              )
              .addTo(document.body)
              .setTag('elevatedRight')
          ],
          [
            boards.unstackables,
            new ElemBoard(boards.unstackables)
              .moveTo(
                boards.elevatedLeft.width + 1 + Math.floor(
                  (boards.stackables.width - boards.unstackables.width) / 2
                ),
                boards.stackables.height + 1
              )
              .addTo(document.body)
              .setTag('unstackables')
          ]
        ])
        const mouseover = document.createElement('div')
        mouseover.className = 'mouseover'
        document.body.appendChild(mouseover)
        let lastHover = null
        let rect
        function updateMouseover (e) {
          const board = e.target.closest('.board')
          let found = false
          if (board && e.target.classList.contains('cell')) {
            const { entries } = boards[board.dataset.tag].getSafely(
              +e.target.dataset.x,
              +e.target.dataset.y
            ) || {}
            if (entries) {
              const width = window.innerWidth
              const height = window.innerHeight
              if (lastHover !== entries) {
                mouseover.innerHTML = ''
                for (const { name, items } of entries) {
                  mouseover.append(
                    Object.assign(document.createElement('span'), {
                      className: 'chest-name minecraft-white',
                      textContent: name
                    }),
                    '\n',
                    Object.assign(document.createElement('span'), {
                      className: 'chest-items minecraft-gray',
                      textContent: items.join(', ')
                    }),
                    '\n',
                  )
                }
                mouseover.style.display = null
                lastHover = entries
                rect = mouseover.getBoundingClientRect()
              }
              found = true
              mouseover.style.left =
                Math.min(e.clientX, width - rect.width) + 'px'
              mouseover.style.top =
                Math.min(e.clientY, height - rect.height) + 'px'
            }
          }
          if (!found && lastHover !== null) {
            mouseover.style.display = 'none'
            lastHover = null
          }
        }
        document.addEventListener('pointerdown', updateMouseover)
        document.addEventListener('pointermove', updateMouseover)

        const searchBox = document.getElementById('search')
        const results = new Directory(document.getElementById('results'))
        function updateFilter (filter) {
          if (filter) {
            const regex = new RegExp(filter, 'ig')
            const lowercaseFilter = filter.toLowerCase()
            const filtered = textures
              .map(item => {
                const id = item.id.slice('minecraft:'.length)
                return {
                  item,
                  // Adding booleans omg
                  score: (item.readable.toLowerCase() === lowercaseFilter) * 2 +
                    (id.toLowerCase() === lowercaseFilter) * 2 +
                    (item.readable.match(regex) || []).length +
                    (id.match(regex) || []).length
                }
              })
              .filter(({ item, score }) => score || results.selected.has(item))
              .sort((a, b) => b.score - a.score)
              .map(({ item }) => item)
            results.students = filtered
            results.filter = regex
            results.updateData()
            results.updateScroll()
          } else {
            results.students = [...results.selected]
            results.filter = new RegExp()
            results.updateData()
            results.updateScroll()
          }
        }
        searchBox.addEventListener('input', e => {
          updateFilter(searchBox.value)
        })

        let wasHighlighted = []
        results.onSelect = targetItems => {
          const ids = new Set(Array.from(targetItems, ({ id }) => id))
          for (const elem of wasHighlighted) {
            elem.classList.remove('highlighted')
          }
          wasHighlighted = chests
            .filter(({ items }) => items.some(item => ids.has(item)))
            .map(({ board, x, y }) => {
              const elem = elemBoards.get(board).get(x, y)
              elem.classList.add('highlighted')
              return elem
            })
        }

        window.addEventListener('resize', results.resize)
        await results.resize()
      }
      main()
    </script>
  </body>
</html>
