<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--
    Thanks to
    https://github.com/destruc7i0n/minecraft-textures
    https://github.com/South-Paw/typeface-minecraft
    -->

    <title>Storage room</title>
    <meta name="description" content="Autosorter too BIG, must FIND"/>

    <link rel="stylesheet" type="text/css" href="/sheep3.css">
    <script src="/sheep3.js" charset="utf-8"></script>

    <style>
      @import url('https://unpkg.com/@south-paw/typeface-minecraft@1.0.0/index.css');
      :root {
        --cell-size: 20px;
      }
      body {
        font-family: 'Minecraft';
        font-size: 12px;
        background-color: #222;
      }
      .board {
        position: absolute;
        top: 0;
        left: 0;
        transform: translate(calc(var(--x) * var(--cell-size)), calc(var(--y) * var(--cell-size)));
        width: calc(var(--width) * var(--cell-size));
        height: calc(var(--height) * var(--cell-size));
        font-size: 0;
        background-size: calc(2 * var(--cell-size));
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200' viewBox='0 0 2 2'%3E%3Cpath fill='%23333' d='M0 0h1v2h1V1H0z'/%3E%3C/svg%3E");
      }
      .cell {
        position: absolute;
        top: 0;
        left: 0;
        width: var(--cell-size);
        height: var(--cell-size);
        image-rendering: crisp-edges;
        image-rendering: pixelated;
        background-size: contain;
        transform: translate(calc(var(--x) * var(--cell-size)), calc(var(--y) * var(--cell-size)));
      }
      .mouseover {
        position: fixed;
        z-index: 5;
        background-color: rgba(15, 0, 15, 0.8);
        border: 1px solid #270658;
        padding: 10px;
        pointer-events: none;
        white-space: pre-wrap;
        max-width: 500px;
      }
      .chest-name,
      .chest-items {
        display: inline-block;
      }
      .chest-name:not(:first-child) {
        margin-top: 10px;
      }
      .chest-items {
        color: rgba(255, 255, 255, 0.5);
      }
      .search-area {
        position: fixed;
        top: 0;
        right: 0;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 1;
        width: 300px;
      }
      .search-box {
        padding: 10px;
        width: 100%;
      }
      .results {
        list-style: none;
        margin: 0;
        padding: 0;
        max-height: 50vh;
        overflow: auto;
      }
      .result {
        padding: 10px;
        padding-left: 40px;
        background-size: 30px;
        background-position: 5px 50%;
        background-repeat: no-repeat;
        white-space: pre-wrap;
      }
      .selected {
        background-color: #6b87b1;
      }
    </style>
  </head>
  <body>
    <div class="search-area">
      <input type="search" class="search-box" id="search" placeholder="Search for items" autofocus>
      <ul class="results" id="results"></ul>
    </div>
    <script type="module">
      import { prepare, findItemBy } from './parse-storage-room.txt.js'
      import { Board, ElemBoard } from './storage-room-a-star.js'

      async function main () {
        const { textures, stackables, data } = await prepare()
        const zStart = stackables.floor1Left[0][0]

        const chests = []
        const chestTexture = findItemBy(textures, 'minecraft:chest').texture
        function addStackablesTo (board, stackables, x) {
          for (const [z, item] of stackables) {
            const entry = findItemBy(textures, item)
            board.setSafely(x, z - zStart, {
              texture: entry.texture,
              entries: [
                {
                  name: entry.readable,
                  items: [item]
                }
              ]
            })
            chests.push({ items: [item], board, x, y: z - zStart })
          }
        }
        function addUnstackablesTo (board, unstackables, x) {
          for (let y = 0; y < unstackables.length; y++) {
            const chestStack = unstackables[y]
            if (chestStack.length) {
              board.setSafely(x, y, {
                texture: chestTexture,
                entries: chestStack
              })
              chests.push({
                items: [].concat(...chestStack.map(chest => chest.items)),
                board,
                x,
                y
              })
            }
          }
        }

        const ladderTexture = findItemBy(textures, 'minecraft:ladder').texture
        function addLadderPair (board1, x1, y1, board2, x2, y2) {
          board1.setSafely(x1, y1, {
            texture: ladderTexture,
            ladder: { board: board2, x: x2, y: y2 }
          })
          board2.setSafely(x2, y2, {
            texture: ladderTexture,
            ladder: { board: board1, x: x1, y: y1 }
          })
        }

        const rows = stackables.floor1Left[stackables.floor1Left.length - 1][0]
          - zStart + 1
        // Magic numbers yes please!
        const boards = {
          stackables: new Board(17, rows),
          elevatedLeft: new Board(5, rows),
          elevatedRight: new Board(5, rows),
          unstackables: new Board(9, data.unstackablesLeft.length + 1)
        }
        addStackablesTo(boards.stackables, stackables.floor1Left, 0)
        addStackablesTo(boards.stackables, stackables.floor1Right, boards.stackables.width - 1)
        addStackablesTo(boards.elevatedLeft, stackables.floor2Left, 0)
        addStackablesTo(boards.elevatedRight, stackables.floor2Right, boards.elevatedRight.width - 1)
        addUnstackablesTo(boards.unstackables, data.unstackablesLeft, 0)
        addUnstackablesTo(boards.unstackables, data.unstackablesRight, boards.unstackables.width - 1)
        addLadderPair(
          boards.stackables,
          Math.floor(boards.stackables.width / 2),
          data.stackableEntrance - zStart,
          boards.unstackables,
          Math.floor(boards.unstackables.width / 2),
          data.unstackablesLeft.length - 1
        )
        for (let y = 5; y < rows; y += 6) {
          addLadderPair(
            boards.stackables,
            5,
            y,
            boards.elevatedLeft,
            boards.elevatedLeft.width - 1,
            y
          )
          addLadderPair(
            boards.stackables,
            11,
            y,
            boards.elevatedRight,
            0,
            y
          )
        }

        const elemBoards = {
          elevatedLeft: new ElemBoard(boards.elevatedLeft)
            .addTo(document.body)
            .setTag('elevatedLeft'),
          stackables: new ElemBoard(boards.stackables)
            .moveTo(boards.elevatedLeft.width + 1, 0)
            .addTo(document.body)
            .setTag('stackables'),
          elevatedRight: new ElemBoard(boards.elevatedRight)
            .moveTo(boards.elevatedLeft.width + boards.stackables.width + 2, 0)
            .addTo(document.body)
            .setTag('elevatedRight'),
          unstackables: new ElemBoard(boards.unstackables)
            .moveTo(
              boards.elevatedLeft.width + 1 + Math.floor(
                (boards.stackables.width - boards.unstackables.width) / 2
              ),
              boards.stackables.height + 1
            )
            .addTo(document.body)
            .setTag('unstackables')
        }
        const mouseover = document.createElement('div')
        mouseover.className = 'mouseover'
        document.body.appendChild(mouseover)
        let lastHover = null
        let rect
        document.addEventListener('pointermove', e => {
          const board = e.target.closest('.board')
          let found = false
          if (board && e.target.classList.contains('cell')) {
            const { entries } = boards[board.dataset.tag].getSafely(
              +e.target.dataset.x,
              +e.target.dataset.y
            ) || {}
            if (entries) {
              const width = window.innerWidth
              const height = window.innerHeight
              if (lastHover !== entries) {
                mouseover.innerHTML = ''
                for (const { name, items } of entries) {
                  mouseover.append(
                    Object.assign(document.createElement('span'), {
                      className: 'chest-name minecraft-white',
                      textContent: name
                    }),
                    '\n',
                    Object.assign(document.createElement('span'), {
                      className: 'chest-items minecraft-gray',
                      textContent: items.join(', ')
                    }),
                    '\n',
                  )
                }
                mouseover.style.display = null
                lastHover = entries
                rect = mouseover.getBoundingClientRect()
              }
              found = true
              mouseover.style.left = Math.min(e.clientX, width - rect.width) + 'px'
              mouseover.style.top = Math.min(e.clientY, height - rect.height) + 'px'
            }
          }
          if (!found && lastHover !== null) {
            mouseover.style.display = 'none'
            lastHover = null
          }
        })

        const searchBox = document.getElementById('search')
        const results = document.getElementById('results')
        function updateFilter (filter) {
          results.innerHTML = ''
          if (filter) {
            const regex = new RegExp(filter, 'ig')
            const filtered = textures
              .map(item => ({
                item,
                score: (item.readable.match(regex) || []).length +
                  (item.id.slice('minecraft:'.length + 1).match(regex) || []).length
              }))
              .filter(({ score }) => score)
              .sort((a, b) => b.score - a.score)
            for (const { item: { readable, id, texture } } of filtered) {
              const result = document.createElement('li')
              result.className = 'result'
              result.style.backgroundImage = `url("${texture}")`
              result.append(
                Object.assign(document.createElement('span'), {
                  className: 'chest-name minecraft-white',
                  innerHTML: readable.replace(regex, '<span class="matched minecraft-green">$&</span>')
                }),
                '\n',
                Object.assign(document.createElement('span'), {
                  className: 'chest-items minecraft-gray',
                  innerHTML: id.replace(regex, '<span class="matched minecraft-green">$&</span>')
                })
              )
              results.appendChild(result)
            }
          }
        }
        searchBox.addEventListener('input', e => {
          updateFilter(searchBox.value)
        })
      }
      main()
    </script>
  </body>
</html>
