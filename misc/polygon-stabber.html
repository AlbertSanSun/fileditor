<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Polygon stabber</title>
    <meta name="description" content="Ray intersecting a polygon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="/sheep3.css">
    <script src="/sheep3.js" charset="utf-8"></script>
    <style>
      body {
        background-color: black;
        color: white;
        font-family: monospace;
      }
      #canvas {
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <p>Click to start a polyline at a point; shift + click to continue from that point. Press Z to remove the last point, and press enter to complete the polygon. Space will clear everything.</p>
    <p>Middle click to set the anchor position.</p>
    <canvas id="canvas" width="480" height="360"></canvas>
    <script type="module">
import { Vector2 } from './artificial-thonkulos/vectors.mjs'

const canvas = document.getElementById('canvas')
const c = canvas.getContext('2d')

const anchor = new Vector2(canvas.width / 2, canvas.height / 2)
const direction = new Vector2(1, 0)

const polygon = [new Vector2(10, 10), new Vector2(400, 30), new Vector2(200, 200), new Vector2(10, 10)]

function raySegmentIntersection (origin, rayDir, a, b) {
  // Ray (for t_r >= 0):
  // <x, y> = origin + rayDir * t_r
  // Segment (for t_s: [0, 1]):
  // <x, y> = a + segmentDir * t_s
  // where segmentDir = b - a
  const segmentDir = b.clone().sub(a)
  // At the intersection, origin + rayDir * t_r = a + segmentDir * t_s
  // This can break down into two equations, one for each component
  // origin.x + rayDir.x * t_r = a.x + segmentDir.x * t_s (same for y)
  // t_r = (a.x + segmentDir.x * t_s - origin.x) / rayDir.x (same for y)
  // (segmentDir.x * t_s + (a.x - origin.x)) / rayDir.x
  // = (segmentDir.y * t_s + (a.y - origin.y)) / rayDir.y
  // rayDir.y * segmentDir.x * t_s + rayDir.y * (a.x - origin.x)
  // = rayDir.x * segmentDir.y * t_s + rayDir.x * (a.y - origin.y)
  // t_s * (rayDir.y * segmentDir.x - rayDir.x * segmentDir.y)
  // = rayDir.x * (a.y - origin.y) - rayDir.y * (a.x - origin.x)
  // t_s = (rayDir.x * (a.y - origin.y) - rayDir.y * (a.x - origin.x))
  //   / (rayDir.y * segmentDir.x - rayDir.x * segmentDir.y)
  const segmentT = (rayDir.x * (a.y - origin.y) - rayDir.y * (a.x - origin.x)) /
    (rayDir.y * segmentDir.x - rayDir.x * segmentDir.y)
  // If t_s is outside of [0, 1], then the intersection was not in the segment
  if (segmentT < 0 || segmentT > 1) return null
  // Recall from before that
  // t_r = (a.x + segmentDir.x * t_s - origin.x) / rayDir.x
  const rayT = (a.x + segmentDir.x * segmentT - origin.x) / rayDir.x
  // If t_r < 0, then the intersection was not on the ray
  if (rayT < 0) return null
  // Get point at t_r
  return origin.clone().add(rayDir.clone().scale(rayT))
}

function rayPolygonIntersection (origin, direction, polygon) {
  let closestIntersection = null
  let closestDistance = Infinity
  for (let i = 1; i < polygon.length; i++) {
    if (polygon[i - 1] && polygon[i]) {
      const point = raySegmentIntersection(origin, direction, polygon[i - 1], polygon[i])
      if (!point) continue
      const distance = point.clone().sub(origin).length
      if (distance < closestDistance) {
        closestDistance = distance
        closestIntersection = point
      }
    }
  }
  return closestIntersection
}

function draw () {
  c.fillStyle = 'rgba(0, 0, 0, 0.1)'
  c.fillRect(0, 0, canvas.width, canvas.height)

  c.strokeStyle = 'grey'
  c.beginPath()
  let moveTo = false
  for (const point of polygon) {
    if (point === null) {
      moveTo = true
    } else {
      if (moveTo) {
        c.moveTo(...point.comps)
        moveTo = false
      } else {
        c.lineTo(...point.comps)
      }
    }
  }
  c.stroke()

  c.strokeStyle = 'blue'
  c.beginPath()
  c.moveTo(...anchor.comps)
  c.lineTo(...direction.clone().scale(100).add(anchor).comps)
  c.stroke()

  c.fillStyle = 'red'
  c.fillRect(anchor.x - 1, anchor.y - 1, 2, 2)

  const intersection = rayPolygonIntersection(anchor, direction, polygon)
  if (intersection) {
    c.fillStyle = 'cyan'
    c.fillRect(intersection.x - 2, intersection.y - 2, 4, 4)
  }
}

document.addEventListener('mousemove', e => {
  const { left, top } = canvas.getBoundingClientRect()
  direction.set({ x: e.clientX - left, y: e.clientY - top })
    .sub(anchor).unit()
  draw()
})
canvas.addEventListener('mousedown', e => {
  const { left, top } = canvas.getBoundingClientRect()
  if (e.which === 2) {
    anchor.set({ x: e.clientX - left, y: e.clientY - top })
    draw()
    e.preventDefault()
  } else if (e.which === 1) {
    if (!e.shiftKey && polygon[polygon.length - 1]) {
      polygon.push(null)
    }
    polygon.push(new Vector2(e.clientX - left, e.clientY - top))
    draw()
  }
})
document.addEventListener('keydown', e => {
  if (e.key.toLowerCase() === 'z') {
    polygon.splice(-1, 1)
    if (polygon[polygon.length - 1] === null) {
      polygon.splice(-1, 1)
    }
    draw()
  } else if (e.key === 'Enter') {
    if (polygon[polygon.length - 1]) {
      const index = polygon.lastIndexOf(null)
      polygon.push(polygon[index < 0 ? 0 : index + 1].clone())
      draw()
    }
  } else if (e.key === ' ') {
    polygon.splice(0, polygon.length)
  }
})

draw()
    </script>
  </body>
</html>
