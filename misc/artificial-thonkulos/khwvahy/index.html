<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>&kappa;&lambda;&omega;&nu;&alpha;&lambda;&gamma;</title>
    <meta name="description" content="Flappy bird AI but they drive cars around a race track with five magic laser beam sensors"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="/sheep3.css">
    <script src="/sheep3.js" charset="utf-8"></script>
    <style>
      html,
      body {
        height: 100%;
      }
      body {
        font-size: 0;
        margin: 0;
        background-color: black;
        font-family: monospace;
      }
      #canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script type="module">
import { BrainType } from '../brain-type.mjs'
import { GenerationManager } from '../generation-manager.mjs'

import { Vector2 } from '../vectors.mjs'
import { rayPolylineIntersection } from '../ray-intersection.mjs'

const CAR_WIDTH = 20 // Distance from centre to side
const CAR_LENGTH = 40 // Distance from centre to front

const MAX_RANGE = 100
const SENSOR_DISTRIB_ANGLE = Math.PI / 8

const TURN_SPEED = 1
const ENGINE_ACCEL = 4
const FRICTION_ACCEL = 1
class Car {
  constructor (brainType) {
    this.brainType = brainType
    this.position = new Vector2()
  }

  get vertices () {
    return [
      new Vector(CAR_LENGTH, CAR_WIDTH),
      new Vector(-CAR_LENGTH, CAR_WIDTH),
      new Vector(-CAR_LENGTH, -CAR_WIDTH),
      new Vector(CAR_LENGTH, -CAR_WIDTH)
    ].map(vec => vec.rotate(this.angle).add(this.position))
  }

  /**
   * Set the weights of the car's neural network
   */
  loadIdeology (ideology) {
    this.ideology = ideology
    return this
  }

  /**
   * Store a reference to the current course
   */
  recognizeReality (reality) {
    this.reality = reality
    return this
  }

  start (position, angle) {
    this.position.set(position)
    this.speed = 0
    this.angle = angle
    this.dead = false
    return this
  }

  sense () {
    const front = new Vector2(CAR_LENGTH, 0).rotate(this.angle).add(this.position)
    const intersections = []
    let angle = -SENSOR_DISTRIB_ANGLE * 2
    const stop = SENSOR_DISTRIB_ANGLE * 2
    while (angle <= stop) {
      intersections.push(rayPolylineIntersection(front,
        new Vector2(1, 0).rotate(angle), this.reality))
      angle += SENSOR_DISTRIB_ANGLE
    }
    return { front, intersections }
  }

  getInputs () {
    const { front, intersections } = this.sense()
    return intersections.map(point => point
      ? Math.min(point.sub(front).length, MAX_RANGE) / MAX_RANGE : 1)
  }

  driveWithFreeWill () {
    const [turn, engine] = this.brainType.ponder(this.ideology, this.getInputs())
    return {
      turnSpeed: (turn - 0.5) * TURN_SPEED,
      engineAccel: (engine - 0.5) * ENGINE_ACCEL
    }
  }

  /**
   * Test each corner of the car and see if the velocity will make it collide
   * with the course
   */
  collision (velocity) {
    return this.vertices.map(vec => vec.rotate(this.angle).add(this.position))
      .some(anchor => rayPolylineIntersection(anchor, velocity, this.reality))
  }

  simulate (time) {
    if (!this.dead) {
      const { turnSpeed, engineAccel } = this.driveWithFreeWill()
      this.angle += turnSpeed * time
      this.speed += engineAccel * time
      if (this.speed > 0) {
        this.speed -= FRICTION_ACCEL * time
        if (this.speed < 0) this.speed = 0
      } else {
        this.speed += FRICTION_ACCEL * time
        if (this.speed > 0) this.speed = 0
      }
      const velocity = new Vector(1, 0).rotate(this.angle).scale(this.velocity)
      if (this.collision(velocity)) {
        this.dead = true
      }
      // Add velocity after since `this.collision` relies on old position
      this.position.add(velocity)
    }
  }

  draw (ctx) {
    ctx.beginPath()
    const [startPoint, ...lineTos] = this.vertices
    ctx.moveTo(...startPoint.comps)
    for (const lineTo of lineTos) {
      ctx.lineTo(...lineTo.comps)
    }
    ctx.closePath()
    ctx.fill()

    const { intersections } = this.sense()
    ctx.beginPath()
    for (const { x, y } of intersections) {
      ctx.moveTo(x - 2, y - 2)
      ctx.lineTo(x + 2, y + 2)
      ctx.moveTo(x + 2, y - 2)
      ctx.lineTo(x - 2, y + 2)
    }
    ctx.stroke()
  }
}

const brainType = new BrainType({ inputs: 5, hiddens: [4, 3], outputs: 2, bias: true })
const generationManager = new GenerationManager({ brainType, count: 50 })
const cars = []
for (let i = 0; i < generationManager.count; i++) {
  cars.push(new Car(brainType).recognizeReality(reality)) // TODO
}

let generation = generationManager.makeGeneration()
let generations = 1
let alive
let record = 0

function startGen () {
  for (let i = 0; i < generationManager.count; i++) {
    cars[i].loadIdeology(generation[i]).start(position, angle) // TODO
  }
  alive = [...cars]
}

function nextGen () {
  // TODO
  cars.sort((a, b) => b.progress - a.progress)
  if (cars[0].progress > record) {
    record = cars[0].progress
  }

  generation = generationManager.nextGeneration(cars.map(car => car.ideology))
  generations++
}

function simulate (simTime) {
  // TODO: Animate camera to winner, etc.

  for (let i = 0; i < alive.length; i++) {
    alive[i].simulate(simTime)
    if (alive[i].dead) {
      alive.splice(i, 1)
      i--
    }
  }

  if (alive.length === 0) {
    nextGen()
    startGen()
  }
}

const canvas = document.getElementById('canvas')
const c = canvas.getContext('2d')

let screenWidth
let screenHeight

function resize () {
  const dpr = window.devicePixelRatio
  screenWidth = window.innerWidth
  screenHeight = window.innerHeight
  canvas.width = screenWidth * dpr
  canvas.height = screenHeight * dpr
  c.scale(dpr, dpr)
}

window.addEventListener('resize', resize)
resize()

function render () {
  //
}

const renderer = new RenderSimulation({ render, simulate })

renderer.start()
    </script>
  </body>
</html>
