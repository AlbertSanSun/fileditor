<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>falppy again</title>
    <meta name="description" content="i look at XVINIETTE for reverefnece"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="/sheep3.css">
    <script src="/sheep3.js" charset="utf-8"></script>
    <style>
      /* TEMP */
    </style>
  </head>
  <body>
    <script>
/**
 * Fancy logistic growth function that outputs a number in (0, 1)
 */
function logistic (n) {
  return 1 / (1 + Math.exp(-n))
}

class BrainType {
  constructor (options = {}) {
    this.options = options

    const {
      inputs = 1,
      hiddens = [],
      outputs = 1
    } = options
    this.layers = [this.inputs, ...this.hiddens, this.outputs]
    this.weights = 0
    for (let i = 0; i < layers.length - 1; i++) {
      this.weights += layers[i] * layers[i + 1]
    }
  }

  makeRandom () {
    const weights = []
    for (let i = 0; i < this.weights; i++) {
      const count = layers[i] * layers[i + 1]
      weights.push(Math.random() * 2 - 1)
    }
    return weights
  }

  radiation (weights) {
    const { mutationRange = 0.5, mutationChance = 0.1 } = this.options
    const newWeights = []
    for (const weight of weights) {
      if (Math.random() < mutationChance) {
        newWeights.push(weight + mutationRange * (Math.random() * 2 - 1))
      }
    }
    return newWeights
  }

  sex (a, b) {
    if (a.length !== this.weights || b.length !== this.weights) {
      throw new Error('Wucky: These are not my people!')
    }
    const { aPreference = 0.5 } = this.options
    const newWeights = []
    for (let i = 0; i < this.weights; i++) {
      if (Math.random() < aPreference) {
        newWeights.push(a[i])
      } else {
        newWeights.push(b[i])
      }
    }
    return newWeights
  }

  ponder (weights, inputs) {
    const { layers } = this
    if (inputs.length !== layers[0]) {
      throw new Error('Wucky: Weird number of inputs given')
    }
    let previousLayer = inputs
    let weight = 0
    for (const layerLength of this.layers.slice(1)) {
      const currentLayer = []
      for (let i = 0; i < layerLength; i++) {
        let sum = 0
        for (const val of previousLayer) {
          sum += weights[weight] * val
          weight++
        }
        currentLayer.push(logistic(sum))
      }
      previousLayer = currentLayer
    }
    return previousLayer
  }
}

class Generations {
  constructor (options = {}) {
    this.options = options

    const { count = 100 } = options
    this.count = count
  }

  makeGeneration () {
    const { brainType } = this.options
    const generation = []
    for (let i = 0; i < count; i++) {
      generation.push(brainType.makeRandom())
    }
    return generation
  }

  /**
   * The generation is expected to be sorted best first
   */
  nextGeneration (generation) {
    const { keepRate = 0.2, randomRate = 0.2, children = 1 } = this.options
    const count = this.count

    if (generation.length !== count) {
      throw new Error('Wucky: This is not my generation')
    }

    const newGeneration = []

    const keep = Math.round(keepRate * count)
    for (let i = 0; i < keep && newGeneration.length < count; i++) {
      newGeneration.push(generation[i])
    }

    const randoms = Math.round(randomRate * count)
    for (let i = 0; i < randoms && newGeneration.length < count; i++) {
      newGeneration.push(brainType.makeRandom())
    }

    // For each individual, breed it with each winner before it
    for (let i = 0; i < generation.length; i++) {
      for (let j = 0; j < i; j++) {
        if (newGeneration.length >= count) {
          return newGeneration
        }
        for (let k = 0; k < children; k++) {
          newGeneration.push(brainType.breed(generation[i], generation[j]))
        }
      }
    }
    throw new Error('Wucky: Not enough children are being born!')
  }
}
    </script>
  </body>
</html>
