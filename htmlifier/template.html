<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>{TITLE}</title>
<style media="screen">
html, body {
  height: 100%;
}
body {
  margin: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: black;
  font-size: 0;
}
#w {
  display: block;
  width: 100vw;
  % 4-3 %
  height: 75vw;
  % /4-3 %
  % 16-9 %
  height: 56.25vw;
  % /16-9 %
  position: relative;
}
#m {
  position: absolute;
  top: 0;
  left: 0;
}
% 4-3 %
@media (min-aspect-ratio: 4/3) {
  #w {
    height: 100vh;
    width: calc(400vh / 3);
  }
}
% /4-3 %
% 16-9 %
@media (min-aspect-ratio: 16/9) {
  #w {
    height: 100vh;
    width: calc(1600vh / 9);
  }
}
% /16-9 %
#s {
  width: 100%;
  height: 100%;
}
% loading-progress %
#l {
  color: #0ff;
  position: fixed;
  bottom: 0;
  left: 0;
  font-size: 16px;
  font-family: monospace;
}
% /loading-progress %
.monitor {
  position: absolute;
  background-color: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 0.25rem;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 0.75rem;
  overflow: hidden;
  padding: 3px;
  color: white;
  white-space: nowrap;
}
.monitor-label {
  margin: 0 5px;
  font-weight: bold;
}
.monitor-value {
  display: inline-block;
  vertical-align: top;
  min-width: 34px;
  text-align: center;
  border-radius: 0.25rem;
  overflow: hidden;
  text-overflow: ellipsis;
  user-select: text;
  transform: translateZ(0);
}
.default .monitor-value, .slider .monitor-value {
  background-color: rgba(0, 0, 0, 0.5);
  margin: 0 5px;
  padding: 1px 3px;
}
.large {
  background-color: rgba(0, 0, 0, 0.6);
  padding: 0.1rem 0.25rem;
  min-width: 3rem;
}
.large .monitor-label {
  display: none;
}
.large .monitor-value {
  font-size: 1rem;
  width: 100%;
}
.list {
  padding: 0;
  overflow: auto;
}
.list .monitor-label {
  text-align: center;
  padding: 3px;
  width: 100%;
  display: block;
  margin: 0;
  box-sizing: border-box;
}
.list .monitor-value {
  display: block;
}
.row {
  margin: 2px 5px;
  transform: translateZ(0);
  text-align: left;
  border-radius: 0.25rem;
  background-color: rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(0, 0, 0, 0.2);
  height: 20px;
  line-height: 20px;
  padding: 0 5px;
  overflow: hidden;
  text-overflow: ellipsis;
}
.slider input {
  display: block;
  width: 100%;
  transform: translateZ(0);
}
</style>
</head>
<body>
<div id="w">
<canvas id="s"></canvas>
<div id="m"></div>
</div>
% no-vm %
% 4-3 %
<script src="https://sheeptester.github.io/scratch-vm/vm.min.js"></script>
% /4-3 %
% 16-9 %
<script src="https://sheeptester.github.io/scratch-vm/16-9/vm.min.js"></script>
% /16-9 %
% /no-vm %
% loading-progress %
<span id="l"></span>
% /loading-progress %
<script type="text/javascript" id="j">
{SCRIPTS}

const Scratch = window.Scratch = window.Scratch || {};

const runBenchmark = function () {
  const vm = new window.NotVirtualMachine();
  Scratch.vm = vm;

  const storage = new ScratchStorage();
  const AssetType = storage.AssetType;
  storage.addWebStore([AssetType.Project], () => PROJECT_JSON);
  storage.addWebStore([AssetType.ImageVector, AssetType.ImageBitmap, AssetType.Sound], asset => ASSETS[asset.assetId]);
  vm.attachStorage(storage);

  % loading-progress %
  const progress = document.getElementById('l');
  const _load = storage.webHelper.load;
  let total = 0, complete = 0;
  storage.webHelper.load = function (...args) {
    const result = _load.call(this, ...args);
    total += 1;
    progress.textContent = complete + '/' + total;
    result.then(() => {
      complete += 1;
      progress.textContent = complete + '/' + total;
    });
    return result;
  };
  % /loading-progress %

  if (SRC === 'file') {
    fetch(FILE)
      .then(r => r.arrayBuffer())
      .then(b => Scratch.vm.loadProject(b));
  } else {
    Scratch.vm.downloadProjectId('');
  }
  vm.on('workspaceUpdate', () => {
    % loading-progress %
    document.body.removeChild(progress);
    % /loading-progress %

    const doNothing = () => null;
    vm.setCloudProvider({
      updateVariable(name, value) {
        try {
          localStorage.setItem('[s3] ' + name, value);
        } catch (e) {
          console.log('Cannot use localStorage?', e);
        }
      },
      createVariable: doNothing,
      renameVariable: doNothing,
      deleteVariable: doNothing,
      requestCloseConnection: doNothing
    });

    setTimeout(() => {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.slice(0, 5) === '[s3] ') {
          vm.postIOData('cloud', {
            varUpdate: {
              name: key.slice(5),
              value: localStorage.getItem(key)
            }
          });
        }
      }
      window.addEventListener('storage', e => {
        if (e.storageArea === localStorage && e.key.slice(0, 5) === '[s3] ') {
          vm.postIOData('cloud', {
            varUpdate: {
              name: e.key.slice(5),
              value: e.newValue
            }
          });
        }
      });
    });

    vm.setCompatibilityMode(COMPAT);
    vm.setTurboMode(TURBO);
    vm.greenFlag();

    document.body.removeChild(document.getElementById('j'));
  });

  function resize() {
    const rect = canvas.getBoundingClientRect();
    renderer.resize(rect.width, rect.height);
    monitorWrapper.style.transform = `scale(${rect.height / 360})`;
  }
  const monitorWrapper = document.getElementById('m');
  const canvas = document.getElementById('s');
  % 4-3 %
  const renderer = new window.ScratchRender(canvas);
  % /4-3 %
  % 16-9 %
  const renderer = new window.ScratchRender(canvas, -320, 320);
  % /16-9 %
  resize();
  Scratch.renderer = renderer;
  vm.attachRenderer(renderer);
  const audioEngine = new window.AudioEngine();
  vm.attachAudioEngine(audioEngine);
  vm.attachV2SVGAdapter(new ScratchSVGRenderer.SVGRenderer());
  vm.attachV2BitmapAdapter(new ScratchSVGRenderer.BitmapAdapter());

  const getEventXY = e => {
    if (e.touches && e.touches[0]) {
      return {x: e.touches[0].clientX, y: e.touches[0].clientY};
    } else if (e.changedTouches && e.changedTouches[0]) {
      return {x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY};
    }
    return {x: e.clientX, y: e.clientY};
  };
  function mousemove(e) {
    const mouse = getEventXY(e);
    const rect = canvas.getBoundingClientRect();
    Scratch.vm.postIOData('mouse', {
      x: mouse.x - rect.left,
      y: mouse.y - rect.top,
      canvasWidth: rect.width,
      canvasHeight: rect.height
    });
  }
  function mousedown(e) {
    const mouse = getEventXY(e);
    const rect = canvas.getBoundingClientRect();
    Scratch.vm.postIOData('mouse', {
      isDown: true,
      x: mouse.x - rect.left,
      y: mouse.y - rect.top,
      canvasWidth: rect.width,
      canvasHeight: rect.height
    });
    e.preventDefault();
  }
  function mouseup(e) {
    const mouse = getEventXY(e);
    const rect = canvas.getBoundingClientRect();
    Scratch.vm.postIOData('mouse', {
      isDown: false,
      x: mouse.x - rect.left,
      y: mouse.y - rect.top,
      canvasWidth: rect.width,
      canvasHeight: rect.height
    });
    e.preventDefault();
  }
  document.addEventListener('mousemove', mousemove);
  canvas.addEventListener('mousedown', mousedown);
  document.addEventListener('mouseup', mouseup);
  document.addEventListener('touchmove', mousemove);
  canvas.addEventListener('touchstart', mousedown, {passive: false});
  document.addEventListener('touchend', mouseup, {passive: false});
  canvas.addEventListener('wheel', e => {
    Scratch.vm.postIOData('mouseWheel', {
      deltaX: e.deltaX,
      deltaY: e.deltaY
    });
    e.preventDefault();
  });
  window.addEventListener('resize', resize);

  document.addEventListener('keydown', e => {
    Scratch.vm.postIOData('keyboard', {
      keyCode: e.keyCode,
      key: e.key,
      isDown: true
    });
    e.preventDefault();
  });
  document.addEventListener('keyup', e => {
    Scratch.vm.postIOData('keyboard', {
      keyCode: e.keyCode,
      key: e.key,
      isDown: false
    });
  });

  Scratch.vm.runtime.addListener('QUESTION', question => {
    if (question !== null)
      Scratch.vm.runtime.emit('ANSWER', prompt(question));
  });

  const getVariable = (targetId, variableId) => {
      const target = targetId ?
          Scratch.vm.runtime.getTargetById(targetId) :
          Scratch.vm.runtime.getTargetForStage();
      return target.variables[variableId];
  };
  const monitorStates = {};
  let once = false;
  Scratch.vm.runtime.addListener('MONITORS_UPDATE', monitors => {
    monitors.forEach((record, id) => {
      if (!monitorStates[id]) {
        const monitor = document.createElement('div');
        monitor.className = 'monitor ' + record.mode;
        monitor.style.left = record.x + 'px';
        monitor.style.top = record.y + 'px';
        if (record.mode === 'list') {
          monitor.style.width = record.width + 'px';
          monitor.style.height = record.height + 'px';
        }
        const label = document.createElement('span');
        label.className = 'monitor-label';
        let name = record.params.VARIABLE || record.params.LIST || record.opcode;
        if (record.spriteName) name = `${record.spriteName}: ${name}`;
        label.textContent = name;
        monitor.appendChild(label);
        const value = document.createElement('span');
        value.className = 'monitor-value';
        monitor.appendChild(value);
        monitorStates[id] = {monitor, value};
        if (record.mode === 'slider') {
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.min = record.sliderMin;
          slider.max = record.sliderMax;
          slider.step = record.isDiscrete ? 1 : 0.01;
          slider.addEventListener('input', e => {
            getVariable(record.targetId, id).value = slider.value;
          });
          slider.addEventListener('change', e => {
            getVariable(record.targetId, id).value = slider.value;
          });
          monitorStates[id].slider = slider;
          monitor.appendChild(slider);
        }
        monitorWrapper.appendChild(monitor);
      }
      monitorStates[id].monitor.style.display = record.visible ? null : 'none';
      if (record.visible) {
        let value = record.value;
        if (typeof value === 'number') {
          value = Number(value.toFixed(6));
        }
        if (typeof value === 'boolean') {
          value = value.toString();
        }
        if (Array.isArray(value)) {
          if (monitorStates[id].lastValue === JSON.stringify(value)) return;
          monitorStates[id].value.innerHTML = '';
          value.forEach(val => {
            const row = document.createElement('div');
            row.className = 'row';
            row.textContent = val;
            monitorStates[id].value.appendChild(row);
          });
        } else {
          monitorStates[id].value.textContent = value;
          if (monitorStates[id].slider) monitorStates[id].slider.value = value;
        }
      }
    });
  });

  Scratch.vm.postIOData('userData', {username: DESIRED_USERNAME});

  vm.start();
};

window.onload = function () {
  runBenchmark();
};
</script>
</body>
</html>
